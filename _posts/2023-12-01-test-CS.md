---
layout: post
title: 니모닉(mnemonic)과 CPU의 기본구조+연산 과정
subtitle: 
categories: CS
tags: [mnemonic,cpu]
---  
## 니모닉(mnemonic)
**니모닉에 대해 설명하기 앞서 이해를 돕기 위해 간략하게 기계어와 명령어 집합 그리고 어셈블리어에 대해 알아보려고 합니다.**

CPU는 1과 0으로 이루어진 기계어만을 사용하며 명령어 집합에 의해 동작됩니다. 

문제는 이 1과 0으로 이루어진 명령어라는 게 CPU마다 다르고 사람이 1과 0만으로 프로그래밍하기가 힘들다는 것인데 이를 해결하기 위해 사람이 이해할 수 있도록 문자화하고 기계어와 1대 1 대응하도록 하여 만든 것이 어셈블리어라고 할 수 있습니다. 

예로 1011 1011이라는 기계어가 어떤 값에 대입을 의미한다면 이를 MOV라는 형식으로 바꿀 수가 있는데 이렇게 1대1 대응하도록 만들어진 언어를 어셈블리어라고 하며 MOV와 같이 사람이 알아보기 쉬운 문자로 된 이러한 기호를 <u>니모닉 기호</u>라고 합니다.  
  
<span style="background-color: yellow;"><strong>정리: 어셈블리어는 주로 기계어 명령어를 대체하는 기호나 짧은 단어인 니모닉기호와 숫자(주소, 상수, 레지스터 번호)로 구성된 프로그래밍 언어</strong></span>
<br>
   
**어셈블리어는 통일된 규격이 없지만 연산 과정을 설명하기 위해 이러한 니모닉 기호를 이용하려고 합니다.** 
<details>
<summary>왜 통일이 안되어있는지에 대한 설명</summary>
<p>어셈블리어가 통일된 표준을 갖지 않는 주된 이유는, 서로 다른 CPU 아키텍처가 각각 고유한 명령어 집합을 가지고 있기 때문입니다. 이러한 명령어 집합은 "명령어 집합 아키텍처(Instruction Set Architecture, ISA)"로 알려져 있으며, 각기 다른 CPU 아키텍처는 이 ISA에 따라 설계됩니다. 그렇기에 각 아키텍처는 고유한 연산 방식을 가지며, 이에 맞는 독특한 명령어 세트를 사용합니다. 이는 어셈블리어가 특정 CPU 아키텍처에 맞춰져 있어야 함을 의미하며, 결과적으로 서로 다른 CPU 아키텍처 간에는 어셈블리어의 호환성이 없다고 설명할 수 있습니다.</p>
</details>   
--------------------------
  
[LOAD] - 메모리에서 CPU로 정보를 가져옵니다.  
[ADD] - 숫자 두 개를 더합니다.  
[STORE] - 메모리에 정보를 저장합니다.    

 
이 외에도 존재하지만 본문에서는 더하기 연산만을 다룰 것이기 때문에 잠시 배제하도록 하겠습니다ㅎㅎ;;

## CPU의 내부 구조
[산술 논리 장치(ALU)] - 두 숫자의 산술 연산과 논리 연산을 담당하는 디지털 회로입니다.  
[제어 장치] - 입출력 장치 간 통신 및 조율을 제어합니다.  
[제어 버스] - CPU와 주변장치 간에 필요한 제어신호를 전송하는 버스입니다.  
[레지스터 세트] - 프로그램 카운터, 명령어 레지스터, 메모리 주소 레지스터, 메모리 버퍼 레지스터, 어큐뮬레이터로 구성된 레지스터 집합을 말합니다.  

<div>
  <img src="/assets/images/CPU구조.jpg" width="500" height="400" alt="CPU구조">
  <p style="font-size:small; text-align:center;">출처: https://slideplayer.com/slide/3558030/</p>
</div>  

## 각각의 레지스터에 대한 설명
[프로그램 카운터] - 다음에 실행될 명령어의 주소를 저장합니다.  
[명령어 레지스터] - 현재 실행되는 명령어를 저장합니다.  
[메모리 주소 레지스터] - 프로그램 카운터에 저장된 명령어 주소가 사용되기 전에 일시적으로 저장합니다.  
[메모리 버퍼 레지스터] - 기억장치에 저장될 데이터 혹은 읽힌 데이터가 일시적으로 저장됩니다.  
[어큐뮬레이터] - 중간 연산 결과 데이터를 일시적으로 저장합니다.    

그럼 이제 내부구조와 니모닉(mnemonic)이라는 것을 알았으니 이를 이용하여 예시를 통해 연산과정을 살펴보려고 합니다.  
**<u>주어지는 연산이 4+5이고 각각의 값들이 저장되는 주소가 아래의 그림과 같을 때, CPU에서 이루어지는 연산 과정</u>**을 나타내 보겠습니다.   

<img src="/assets/images/연산과정.png" width="200" height="400" alt="연산과정">  
<center><b>※값과 주소는 이진법으로 표현되지만 이해를 돕기 위해 위와 같이 표기하였습니다.</b></center>  
<br>  

1. 먼저 프로그램 카운터(PC)에 명령어가 시작되는 주소를 저장하는데 가장 처음 시작되는 명령어는 LOAD 10이므로 PC에 100을 저장합니다.
2. PC에 저장된 100이 메모리 주소 레지스터(MAR)로 전달됩니다.
3. MAR에 저장된 주소가 가리키는 값인 LOAD 10이 메모리 버퍼 레지스터(MBR)로 전달됩니다.
4. MBR로 전달된 LOAD 10은 명령어이기 때문에 이를 명령어 레지스터(IR)로 전달합니다.
5. PC에 다음에 올 명령어 주소를 저장합니다.
6. 명령어 레지스터에 저장되어있는 LOAD 10이 제어장치로 들어가고 이를 수행하여 10번 주소를 가져와 메모리 주소 레지스터에 저장합니다.
7. 메모리 버퍼 레지스터에 10이 가르키는 값인 4를 저장합니다.
8. 4는 명령어가 아니기 때문에 명령어 레지스터가 아닌 어큐뮬레이터로 전달됩니다.
9. 프로그램 카운터에 저장되어있는 101이 메모리 주소 레지스터로 전달됩니다.
10. 101이 가르키는 ADD 11이 메모리 버퍼 레지스터로 전달되고 이는 명령어기 때문에 명령어 레지스터로 전달합니다.
11. 프로그램 카운터를 1 증가시킵니다.
12. 제어 장치로 ADD 11을 전달합니다. 그리고 이제 ADD를 하기 위해 어큐뮬레이터에 존재하는 4를 ALU로 전달합니다.
13. 메모리 주소에 11을 저장하고 이때 11에 저장돼있는 값인 5가 메모리 버퍼 레지스터와 어큐뮬레이터를 거쳐 산술 논리 장치에 전달되어 4+5인 9가 도출되게 됩니다.